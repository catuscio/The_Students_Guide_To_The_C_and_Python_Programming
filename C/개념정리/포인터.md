# 포인터(pointer)
- 포인터란 말 그대로 '가르키는' 것, 즉 메모리 주소를 말한다.
- __자료형에 관계 없이 포인터 자료형의 길이는 늘 4Bytes로 일정하다.__

## 표기
``` c
char *pch;    //문자형 포인터 변수 pch 선언
int *pnum;    //정수형 포인터 변수 pnum 선언
```
이런 방식으로 포인터를 선언할 수 있다. 단 포인터 변수는 주소를 할당해 주어야 하는데, 다른 변수와 마찬가지로 선언과 동시에 초기화가 가능하다.
``` c
int num, *pnum = &num   //pnum을 선언과 동시에 num의 주소로 초기화
```
포인터를 어떤 변수의 주소로 초기화할지 알 수 없으면 NULL로 초기화하면 된다.
```c
int *p = NULL;
int *q = 0;
```

## 대입(혹은 저장)
```c
char ch = 'A', *pch;  //ch변수 선언과 동시에 'A'로 초기화, 포인터 변수 pch 선언
int num = 3, *pnum;

pch = &ch;            //pch에 변수 ch의 주소 대입(연결)
pnum = &num;  

printf("%p %c \n", pch, ch);     //%p: 주소 출력 서식
printf("%p %d \n", pnum, num);
```
아니면 이런 방식으로 연결할 수도 있다.
``` c
int num = 3, *pnum = &num
```

## 역참조 연산자(*)
### 간접접근, 직접접근
- 포인터 주소로의 접근을 간접접근이라 한다.
- 포인터가 가리키는 변수로의 접근을 직접접근이라 한다.
```c
ch = 'B';   //직접접근
*pch = 'B'; //간접접근
```
__즉 `*pch`는 '값'으로의 접근이다.__\
__반대로 `pch`는 '주소'(001E40B4 등)로의 접근이다.__

### 함수에서의 포인터(참조에 의한 호출)
- 함수의 매개변수는 인자를 가리키는 포인터로 선언할 수 있다.
```c
void print(int *p);
```
함수를 호출할 때, 이와 같이 접근 가능하다.
```c
void print(int* p) {
  printf(p);
}

int main() {
  int a = 100;
  print(&a);
}
```

-----
## 배열과 포인터
- 배열과 포인터는 기본적으로 비슷하게 주소를 의미한다.
> 가령 배열 이름 'arr'는 배열의 0번 원소의 시작 주소 '&a[0]'을 의미한다.

### 활용
``` c
int arr[5] = {2, 3, 5, 7, -1};
printf("%p %d %d\n", arr+1, arr[1], *(ar+1))
```
```c
001E40B8 3 3
```

`*p`는 값으로의 접근이므로, `arr[1]`와 `*(arr+1)`는 같은 값이다.\
__즉, 포인터 p가 배열 arr를 가리킬 때, *(p+i)는 arr[i]를 의미한다.__\
또한, p[i]로도 쓸 수 있다.\
함수를 선언할 때에도 마찬가지로, 배열의 크기를 생략하고 선언하거나 배열 원소에 대한 포인터형으로 선언한다.
```c
void print_Array(int* arr);
void print_Array(int arr[]);
```
둘은 같은 의미이다.

---
## 문자열과 포인터
> 문자열 선언
```c
char str1[6] = "Hello";

printf("%c", str1[0]);    //O
printf("%s", str1);       //O

str1[0] = 'h';            //O
scanf("%s", str1);        //O

str1 = "World";           //X
//선언과 동시에만 문자열로 초기화 가능
```

> 문자형 포인터 선언
```c
char *str2 = "Hello";

printf("%c", str2[0]);    //O
printf("%s", str2);       //O

str2[0] = 'h';            //X
scanf("%s", str2);        //X

str2 = "World";           //O
```
- `*str2`에서 `"Hello"`는 __문자열 상수__ 로, 사용자 프로그램에서는 변경할 수 없다.
- 단, `"Hello"`로 연결되어 있는 `str2`는 __상수__ 가 아니므로, `str2 = "World"`로 변경할 수 있다.
- 즉, __*str이 포인터여서 문자 변경이 안 되는 것이 아니라, str이 가리키는 영역의 성질에 따라 변경 여부가 달라진다.*__
> 문자형 포인터로 배열을 선언할 경우, 포인터 변수가 가리키는 메모리 영역에 적힌 문자열로 초기화 되므로, 문자열의 길이가 그 문자열로 결정된다.

